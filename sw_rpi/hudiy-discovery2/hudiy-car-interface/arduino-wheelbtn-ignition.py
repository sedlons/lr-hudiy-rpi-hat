#
#  Project: HUDIY Discovery II
#  Autor: Robert Sedlacek
#

import common.Api_pb2 as hudiy_api
from common.Client import Client, ClientEventHandler
import serial
import subprocess
import threading
from collections import deque

# Arduino serial port
SERIAL_PORT = "/dev/ttyUSB0"
BAUD_RATE = 115200  # uprav podle svého zařízení

BACKLIGHTAPP = "/home/pi/ws-backlight"
BACKLIGHT_DAY = 100
BACKLIGHT_NIGHT = 15

# Global variables
ignition = 1
reverse_gear = 0
backlight_current = -1
ignition_timer = None
# Variables for wheel button debounce
BUTTON_DEBOUNCE_COUNT = 3
button_history = deque(maxlen=BUTTON_DEBOUNCE_COUNT)
last_confirmed_button = None


# Event handler for events generated by hudiy
class EventHandler(ClientEventHandler):
    def on_hello_response(self, client, message):
        print(
            "received hello response, result: {}, app version: {}.{}, api version: {}.{}"
            .format(message.result, message.app_version.major,
                    message.app_version.minor, message.api_version.major,
                    message.api_version.minor))

        set_status_subscriptions = hudiy_api.SetStatusSubscriptions()
        set_status_subscriptions.subscriptions.append(hudiy_api.SetStatusSubscriptions.Subscription.MEDIA)
        client.send(hudiy_api.MESSAGE_SET_STATUS_SUBSCRIPTIONS, 0, set_status_subscriptions.SerializeToString())


# Trigger action like next song, volume up etc...
def trigger_action(client, actionstr):
    try:
        dispatch_action = hudiy_api.DispatchAction()
        dispatch_action.action = actionstr
        client.send(hudiy_api.MESSAGE_DISPATCH_ACTION, 0, dispatch_action.SerializeToString())
    except Exception as e:
        print(f"[ERROR] Failed to trigger action {actionstr}: {e}")


def toggle_dark_mode_by_backlight(client, backlight):
    if backlight < 40:
        enabled = True
    elif backlight > 60:
        enabled = False
    else:
        return

    try:
        set_dark_mode = hudiy_api.SetDarkMode()
        set_dark_mode.enabled = enabled
        client.send(hudiy_api.MESSAGE_SET_DARK_MODE, 0, set_dark_mode.SerializeToString())
    except Exception as e:
        print(f"[ERROR] Failed to send day/night mode: {e}")


def power_off():
    subprocess.run("sudo shutdown -h now", shell=True, check=True)


def steering_wheel_btn_distinguish(client, adc_value: int):
    button_map = {
        "output_volume_down": 0,  # VOLUME_DOWN
        "output_volume_up": 390,  # VOLUME_UP
        "now_playing_next_track": 860,  # SEARCH_DOWN
        "now_playing_previous_track": 1680,  # SEARCH_UP
        "resume_android_auto_projection": 2680,  # MODE
        "fm_radio_player": 3680,  # END
    }

    # přepočet na rozsah AD převodníku (příklad s odporem 4k7)
    res_R9 = 4700.0
    for name, ohm in button_map.items():
        ad = int(1024.0 * ohm / (ohm + res_R9))
        button_map[name] = ad

    # vyber nejbližší hodnotu
    best_btn = None
    best_diff = 9999
    for name, ad in button_map.items():
        diff = abs(adc_value - ad)
        if diff < best_diff:
            best_btn = name
            best_diff = diff

    # tolerance (např. ±30)
    if best_diff < 30:
        button_history.append(best_btn)
        # If three consequent read are same
        if len(button_history) == BUTTON_DEBOUNCE_COUNT and len(set(button_history)) == 1:
            global last_confirmed_button
            if best_btn != last_confirmed_button:
                trigger_action(client, best_btn)
                print(f"[BUTTON] Confirmed: {best_btn} ({adc_value})")
                last_confirmed_button = best_btn
    else:
        # Reset button history
        button_history.clear()
        last_confirmed_button = None


def heater_distinguish(client, value):
    if value:
        print(f"[HEATER] On => RPi poweroff: {value}")
        power_off()


def ignition_distinguish(client, value):
    global ignition, ignition_timer

    if ignition != value:
        ignition = value
        print(f"[IGNITION] change: {value}")

        # když se klíček vypne (IGN == 0)
        if value == 0:
            print("[IGNITION] Key OFF → start 2min shutdown timer")
            # pokud už nějaký timer běží, stopni ho
            if ignition_timer is not None:
                ignition_timer.cancel()
            # vytvoř nový timer na 120 sekund
            ignition_timer = threading.Timer(100, power_off)
            ignition_timer.start()

        # když se klíček zapne (IGN == 1)
        elif value == 1:
            print("[IGNITION] Key ON → cancel shutdown timer")
            # zruš běžící timer
            if ignition_timer is not None:
                ignition_timer.cancel()
                ignition_timer = None


def reverse_gear_distinguish(client, value):
    global reverse_gear
    if reverse_gear != value:
        reverse_gear = value
        print(f"[REVERSEGEAR] change: {value}")

        if value:
            trigger_action(client, "show_reverse_camera")
        else:
            trigger_action(client, "hide_reverse_camera")


def light_sense_distinguish(client, light_intensity):
    global backlight_current

    if light_intensity > 300:
        backlight_new = BACKLIGHT_DAY
    else:
        backlight_new = BACKLIGHT_NIGHT

    # Call change backlight app only when change
    if backlight_new != backlight_current:
        print(f"[BACKLIGHT] Backlight: {backlight_new}")
        subprocess.run([BACKLIGHTAPP, str(backlight_new)])
        toggle_dark_mode_by_backlight(client, backlight_new)
        backlight_current = backlight_new


# Must be here, otherwise connection is broken after few moments
def hudiy_listener(client):
    print("[INFO] HUDIY listener started")
    while True:
        try:
            client.wait_for_message()
        except Exception as e:
            print(f"[ERROR] HUDIY listener failed: {e}")
            break


def main():
    # Connection to hudiy
    client = Client("HUDIY Discovery II")
    event_handler = EventHandler()
    client.set_event_handler(event_handler)
    client.connect('127.0.0.1', 44406, use_websocket=True)

    threading.Thread(target=hudiy_listener, args=(client,), daemon=True).start()

    # Reading from serial port
    with serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1) as ser:
        # hudiy_receive_active = True
        print(f"[INFO] Listening on {SERIAL_PORT} at {BAUD_RATE} baud")
        while True:
            # Keep hudiy event listener on
            # try:
            #    hudiy_receive_active = client.wait_for_message()
            # except Exception as e:
            #    print(f"[ERROR] Poll failed: {e}")

            # Read serial line
            line = ser.readline().decode(errors="ignore").strip()
            if not line:
                continue

            parts = line.split()

            # Create dict only for parts with ':'
            values = {}
            for part in parts:
                if ":" in part:
                    key, val = part.split(":")
                    try:
                        values[key] = int(val)
                    except ValueError:
                        continue

            # print(values)

            if "IGN" in values:
                ignition_distinguish(client, values["IGN"])

            if "WHBTN" in values:
                steering_wheel_btn_distinguish(client, int(values["WHBTN"]))

            if "HEATER" in values:
                heater_distinguish(client, values["HEATER"])

            if "REVERSE" in values:
                reverse_gear_distinguish(client, values["REVERSE"])

            if "LSENS" in values:
                light_sense_distinguish(client, values["LSENS"])

    client.disconnect()


if __name__ == "__main__":
    main()